
==== Top 8 Chunks for Query: - ====

--- Chunk 1 ---
=== Page 574 === 16.1 Further Topics in Functional Dependencies: Inference Rules, Equivalence, and Minimal Cover 545 16.1 Further Topics in Functional Dependencies: Inference Rules, Equivalence, and Minimal Cover We introduced the concept of functional dependencies (FDs) in Section 15.2, illus- trated it with some examples, and developed a notation to denote multiple FDs over a single relation. We identified and discussed problematic functional dependencies in Sections 15.3 and 15.4 and showed how they can be eliminated by a proper decomposition of a relation. This process was described as normalization and we showed how to achieve the first through third normal forms (1NF through 3NF) given primary keys in Section 15.3. In Sections 15.4 and 15.5 we provided general- ized tests for 2NF, 3NF, and BCNF given any number of candidate keys in a relation and showed how to achieve them. Now we return to the study of functional depen- dencies and show how new dependencies can be inferred from a given set and dis- cuss the concepts of closure, equivalence, and minimal cover that we will need when we later consider a synthesis approach to design of relations given a set of FDs. 16.1.1 Inference Rules for Functional Dependencies We denote by F the set of functional dependencies that are specified on relation schema R. Typically, the schema designer specifies the functional dependencies that are semantically obvious; usually, however, numerous other functional dependencies hold in all legal relation instances among sets of attributes that can be derived from and satisfy the dependencies in F. Those other dependencies can be inferred or deduced from the FDs in F. In real life, it is impossible to specify all possible functional dependencies for a given situation. For example, if each department has one manager, so that Dept_no uniquely determines Mgr_ssn (Dept_no →Mgr_ssn), and a manager has a unique phone number called Mgr_phone (Mgr_ssn →Mgr_phone), then these two dependen- cies together imply that Dept_no →Mgr_phone. This is an inferred FD and need not be explicitly stated in addition to the two given FDs. Therefore, it is useful to define a concept called closure formally that includes all possible dependencies that can be inferred from the given set F. Definition. Formally, the set of all dependencies that include F as well as all dependencies that can be inferred from F is called the closure of F; it is denoted by F+. For example, suppose that we specify the following set F of obvious functional dependencies on the relation schema in Figure 15.3(a): F = {Ssn →{Ename, Bdate, Address, Dnumber}, Dnumber →{Dname, Dmgr_ssn} } Some of the additional functional dependencies that we can infer from F are the fol- lowing: Ssn →{Dname, Dmgr_ssn} Ssn →Ssn Dnumber →Dname === Page 575 === 546 Chapter 16 Relational Database Design Algorithms and Further Dependencies An FD X →Y is inferred from a set of dependencies F specified on R if X →Y holds in every legal relation state r of R; that is, whenever r satisfies all the depend- encies in F, X →Y also holds in r. The closure F+ of F is the set of all functional dependencies that can be inferred from F. To determine a systematic way to infer dependencies, we must discover a set of inference rules that can be used to infer new dependencies from a given set of dependencies. We consider some of these inference rules next. We use the notation F |=X →Y to denote that the functional dependency X →Y is inferred from the set of functional dependencies F. In the following discussion, we use an abbreviated notation when discussing func- tional dependencies. We concatenate attribute variables and drop the commas for convenience. Hence, the FD {X,Y} →Z is abbreviated to XY →Z, and the FD {X, Y, Z} →{U, V} is abbreviated to XYZ →UV. The following six rules IR1 through IR6 are well-known inference rules for functional dependencies: IR1 (reflexive rule)1: If X ⊇Y, then X →Y. IR2 (augmentation rule)2: {X →Y} |=XZ →YZ. IR3 (transitive rule): {X →Y, Y →Z} |=X →Z. IR4 (decomposition, or projective, rule): {X →YZ} |=X →Y. IR5 (union, or additive, rule): {X →Y, X →Z} |=X →YZ. IR6 (pseudotransitive rule): {X →Y, WY →Z} |=WX →Z. The reflexive rule (IR1) states that a set of attributes always determines itself or any of its subsets, which is obvious. Because IR1 generates dependencies that are always true, such dependencies are called trivial. Formally, a functional dependency X →Y is trivial if X ⊇Y; otherwise, it is nontrivial. The augmentation rule (IR2) says that adding the same set of attributes to both the left- and right-hand sides of a depen- dency results in another valid dependency. According to IR3, functional dependen- cies are transitive. The decomposition rule (IR4) says that we can remove attributes from the right-hand side of a dependency; applying this rule repeatedly can decom- pose the FD X →{A1, A2, ..., An} into the set of dependencies {X →A1, X →A2, ..., X →An}. The union rule (IR5) allows us to do the opposite; we can combine a set of dependencies {X →A1, X →A2, ..., X →An} into the single FD X →{A1, A2, ..., An}. The pseudotransitive rule (IR6) allows us to replace a set of attributes Y on the left hand side of a dependency with another set X that functionally determines Y, and can be derived from IR2 and IR3 if we augment the first functional dependency X →Y with W (the augmentation rule) and then apply the transitive rule. One cautionary note regarding the use of these rules. Although X →A and X →B implies X →AB by the union rule stated above, X →A and Y →B does imply that XY →AB. Also, XY →A does not necessarily imply either X →A or Y →A. 1The reflexive rule can also be stated as X →X; that is, any set of attributes functionally determines itself. 2The augmentation rule can also be stated as X →Y |=XZ →Y; that is, augmenting the left-hand side attributes of an FD produces another valid FD.

--- Chunk 2 ---
=== Page 115 === 80 CHAPTER'3 Figure 3.13 Manages and WorksJn CREATE TABLE DepLMgr ( did INTEGER, dname CHAR(20) , budget REAL, ssn CHAR(11) NOT NULL, since DATE, PRIMARY KEY (did), FOREIGN KEY (ssn) REFERENCES Employees ON DELETE NO ACTION) It also captures the participation constraint that every department must have a manager: Because ssn cannot take on null values, each tuple of DepLMgr identifies a tuple in Employees (who is the manager). The NO ACTION specifi- cation, which is the default and need not be explicitly specified, ensures that an Employees tuple cannot be deleted while it is pointed to by a Dept-Mgr tuple. If we wish to delete such an Employees tuple, we must first change the DepLMgr tuple to have a new employee &'3 manager. (vVe could have specified CASCADE instead of NO ACTION, but deleting all information about a department just because its manager has been fired seems a bit extreme!) The constraint that every department must have a manager cannot be cap- tured using the first translation approach discussed in Section 3.5.3. (Look at the definition of lVIanages and think about what effect it would have if we added NOT NULL constraints to the ssn and did fields. Hint: The constraint would prevent the firing of a manager, but does not ensure that a manager is initially appointed for each department!) This situation is a strong argument === Page 116 === The Relational lvfodel 8~ in favor of using the second approach for one-to-many relationships such as Manages, especially when the entity set with the key constraint also has a total participation constraint. Unfortunately, there are many participation constraints that we cannot capture using SQL, short of using table constraints or assertions. Table constraints and assertions can be specified using the full power of the SQL query language (as discussed in Section 5.7) and are very expressive but also very expensive to check and enforce. For example, we cannot enforce the participation constraints on the \iVorks_In relation without using these general constraints. To see why, consider the Works-ln relation obtained by translating the ER diagram into· relations. It contains fields ssn and did, which are foreign keys referring to Employees and Departments. To ensure total participation of Departments in Works_In, we have to guarantee that every did value in Departments appears in a tuple of Works_In. We could try to guarantee this condition by declaring that did in Departments is a foreign key referring to Works_In, but this is not a valid foreign key constraint because did is not a candidate key for Works_In. To ensure total participation of Departments in Works_In using SQL, we need an assertion. We have to guarantee that every did value in Departments appears in a tuple of Works_In; further, this tuple of Works_In must also have non-null values in the fields that are foreign keys referencing other entity sets involved in the relationship (in this example, the ssn field). We can ensure the second part of this constraint by imposing the stronger requirement that ssn in Works-ln cannot contain null values. (Ensuring that the participation of Employees in Works_In is total is symmetric.) Another constraint that requires assertions to express in SQL is the requirement that each Employees entity (in the context of the Manages relationship set) must manage at least one department. In fact, the Manages relationship set exemplifies most of the participation con- straints that we can capture using key and foreign key constraints. Manages is a binary relationship set in which exactly one of the entity sets (Departments) has a key constraint, and the total participation constraint is expressed on that entity set. \Ve can also capture participation constraints using key and foreign key con- straints in one other special situation: a relationship set in which all participat- ing entity sets have key constraints and total participation. The best translation approach in this case is to map all the entities &'3 well as the relationship into a single table; the details are straightforward.

--- Chunk 3 ---
=== Page 646 === Scherna Refine'rnent and NornuIl }'OT'lnS 19.2 FUNCTIONAL DEPENDENCIES 611 A functional dependency (FD) is a kind of Ie that generalizes the concept of a key. Let R be a relation scherna and let ..¥" and Y be nonernpty sets of attributes in R. We say that an instance r of R satisfies the FDX ~ }i 1 if the following holds for every pair of tuples tl and t2 in r-. If t1.X = t2 ..X, then tl.}T = t2.Y'". w(~ use the notation tl.X to refer to the projection of tuple t1 onto the at- tributes in .<\'", in a natural extension of our TIlC notation (see Chapter 4) t.a for referring to attribute a of tuple t. An FD X ----7 Yessentially says that if two tuples agree on the values in attributes X, they 111Ust also agree on the values in attributes Y. Figure 19.3 illustrates the rneaning of the FD AB ----7 C by showing an instance that satisfies this dependency. The first two tuples show that an FD is not the same as a key constraint: Although the FD is not violated, AB is clearly not a key for the relation. The third and fourth tuples illustrate that if two tuples differ in either the A field or the B field, they can differ in the C field without violating the FD. On the other hand, if we add a tuple (aI, bl, c2, dl) to the instance shown in this figure, the resulting instance would violate the FD; to see this violation, compare the first tuple in the figure with the new tuple. -- ...-......................... ..."""......................"N a1 b1 c1 d1 a1 b1 c1 d2 a1 b2 c2 dl a2 bl c3 ell ...............""...............,."'" ' ........ n ....' ...................-.---- -"- Figure 19.3 An Instance that Satisfies AB -Jo C Ilecall that a legal instance of a relation nUlst satisfy all specified les, including all specified FDs. As noted in Section 3.2, Ies rIlust be identified and specified ba...sed on the sernantics of the real-world enterprise being n1odeled. By looking at an instance of a relation, we rnight be able to tell that a certain FD does not hold. I-Iowever; we C<-:l.Tl never deduce that an FD docs hold by looking at one or 1I10re instances of the relation, beca,use an FD, like other les, is a staternent about all possible legal instances of the relation. 1X _._, Y is re,lel aAS X fu'nctionally deteTrninc8 Y, or simply a..s X determ'ines Y. === Page 647 === 612 C~HAP'TgR 19 .A prirnary key constraint is a special ease of an .1"1). The attributes in the key play the role of X, and the set of all attributes in the relation plays the role of Y. Note, ho\vever, that the definition of an FD does not require that the set ..Y" be 111iniInal; the additionalrninimality condition Illust be Inet for -'~ to be a key. If ..~ ----+Y holds, \vhere Y" is the set of all attributes, and there is SCHne (strictly contajned) subset llof .iJ( such that 1/ ----+ },~ holds, then ..X" is a 81LIJerkey. In the rest of this chapter, ·we see several exarIlples of FDs that are not key constraints. 19.3 REASONING ABOUT FDS Given a set of FDs over a relation scheula .R, typically several additional FDs hold over R whenever all of the given FDs hold. As an exalnple, consider: WorkersC~~n, naTne, lot, did, since) We know that ssn ----+ did holds, since ssn is the key, and FD did ----+ lot is given to hold. Therefore, in any legal instance of Workers, if two tuples have the same ssn value, they Blust have the sarne did value (frolH the first FD), and because they have the sarrle did value, they must also have the saIne lot value (1'1'0111 the second FD). Therefore, the FD ssn ----+ lot also holds on Workers. We say that an FD f is implied by a given set F of FDs if f holds on every relation instance that satisfies all dependencies in F; that is, f holds whenever all FDs in F hold. Note that it is not sufficient for f to hold on SaIne instance that satisfies all dependencies in F; rather, f rnust hold on every instance that satisfies all dependencies in P'. 19.3.1 Closure of a Set of FDs The set of all .FDs irnplied by a given set F of FDs is called the closllre of Ji-', denoted as .F'+. An irnportant question is how we can infer, or cornpute, the closure of a given set ]? of FDs. ~rhe answer is sirnple and elegant. The folhwving three rules, called Armstrong's Axioms, can be applied repeatedly to infer all FI)s irnplied by a set ]? of FDs. \lVe use ..,""Y, and Z to denote scts of attributes over a relation scherna It: \I Reflexivity: If X ~ }T, then X ----+ Y. \I Augn1.entation: If )( -'tY, then ..YZ ---t }TZ for any Z. 11II Transitivity: If)( ----+Y (urd Y === Page 648 === Sche-rna Rejinenu:nt and lVoT'lnall?oTTns 61~ Theorem 1 AT1nstrong'8 A:riorns are sound J in that they gene1ute only 1t'Ds in F"+- 'when apT)l'ied to a set, F of j?D8. They are also completeJ in that repeated a]Jplicat'ion afthese T"ules 1JJill generate all FDs in the ClOS'U7"'e .Fl+. The soundness of Arrnstrong's Axiorns is straightfor\vard to prove. Cornplete- ness is harder to show; see Exercise 19.17. It is convenient to use SOlne additional rules while rea..soning about P+: • Union: If X ~ Yand X ~ Z, then X ~ YZ. • Decomposition: If X -+ YZ, then X ~ y' and X -7 Z. These additional rules are not essential; their soundness can be proved using Armstrong's AxiolllS. To illustrate the use of these inference rules for FDs, consider a relation schelua ABC with FDs A ····-*B and B -7 C. In a trivial FD, the right side contains only attributes that also appear on the left side; such dependencies always hold due to reflexivity. Using reflexivity, we can generate all trivial dependencies, which are of the form: X ~ Y, where Y ~ X, X ~ ABC, and Y ~ ABC. FrOHl transitivity we get A -+ C. Fronl auglnentation we get the nontrivial dependencies: AC--->- BG Y , AB -7 AC', AB -7 C13. As another exalnple, we use a rnore elaborate version of Contracts: Contracts(!:..9ntractid, supplierid, pro,jectid, dept'id, partid, qty, val'ue) \Ve denote the schenla for Contracts a..s CSJDPQ V. The rneaning of a tuple is that the contract with contractid C is an agreelnent that supplier S (sv,pplierid) 'will supply Q iterns of part? (par-tid) to project J (pTo,ject'id) associated with departrnent D (deptid); the value tl of this contract is equal to value. The following res are known to hold: 1. 1'he contract id Gl is a key: C -+ CSJDP(J V. 2. A project purclHlses a given part using a single contract: .II) --+ C 1 •

--- Chunk 4 ---
=== Page 176 === 6.1 Unary Relational Operations: SELECT and PROJECT 147 culus.2 In tuple relational calculus, variables range over tuples, whereas in domain relational calculus, variables range over the domains (values) of attributes. In Appendix C we give an overview of the Query-By-Example (QBE) language, which is a graphical user-friendly relational language based on domain relational calculus. Section 6.8 summarizes the chapter. For the reader who is interested in a less detailed introduction to formal relational languages, Sections 6.4, 6.6, and 6.7 may be skipped. 6.1 Unary Relational Operations: SELECT and PROJECT 6.1.1 The SELECT Operation The SELECT operation is used to choose a subset of the tuples from a relation that satisfies a selection condition.3 One can consider the SELECT operation to be a filter that keeps only those tuples that satisfy a qualifying condition. Alternatively, we can consider the SELECT operation to restrict the tuples in a relation to only those tuples that satisfy the condition. The SELECT operation can also be visualized as a horizontal partition of the relation into two sets of tuples—those tuples that sat- isfy the condition and are selected, and those tuples that do not satisfy the condition and are discarded. For example, to select the EMPLOYEE tuples whose department is 4, or those whose salary is greater than $30,000, we can individually specify each of these two conditions with a SELECT operation as follows: σDno=4(EMPLOYEE) σSalary>30000(EMPLOYEE) In general, the SELECT operation is denoted by σ<selection condition>(R) where the symbol σ (sigma) is used to denote the SELECT operator and the selec- tion condition is a Boolean expression (condition) specified on the attributes of relation R. Notice that R is generally a relational algebra expression whose result is a relation—the simplest such expression is just the name of a database relation. The relation resulting from the SELECT operation has the same attributes as R. The Boolean expression specified in <selection condition> is made up of a number of clauses of the form <attribute name> <comparison op> <constant value> or <attribute name> <comparison op> <attribute name> 2In this chapter no familiarity with first-order predicate calculus—which deals with quantified variables and values—is assumed. 3The SELECT operation is different from the SELECT clause of SQL. The SELECT operation chooses tuples from a table, and is sometimes called a RESTRICT or FILTER operation. === Page 177 === 148 Chapter 6 The Relational Algebra and Relational Calculus where <attribute name> is the name of an attribute of R, <comparison op> is nor- mally one of the operators {=, <, ≤, >, ≥, ≠}, and <constant value> is a constant value from the attribute domain. Clauses can be connected by the standard Boolean oper- ators and, or, and not to form a general selection condition. For example, to select the tuples for all employees who either work in department 4 and make over $25,000 per year, or work in department 5 and make over $30,000, we can specify the following SELECT operation: σ(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000)(EMPLOYEE) The result is shown in Figure 6.1(a). Notice that all the comparison operators in the set {=, <, ≤, >, ≥, ≠} can apply to attributes whose domains are ordered values, such as numeric or date domains. Domains of strings of characters are also considered to be ordered based on the col- lating sequence of the characters. If the domain of an attribute is a set of unordered values, then only the comparison operators in the set {=, ≠} can be used. An exam- ple of an unordered domain is the domain Color = { ‘red’, ‘blue’, ‘green’, ‘white’, ‘yel- low’, ...}, where no order is specified among the various colors. Some domains allow additional types of comparison operators; for example, a domain of character strings may allow the comparison operator SUBSTRING_OF. In general, the result of a SELECT operation can be determined as follows. The <selection condition> is applied independently to each individual tuple t in R. This is done by substituting each occurrence of an attribute Ai in the selection condition with its value in the tuple t[Ai]. If the condition evaluates to TRUE, then tuple t is Fname Minit Lname Ssn Bdate Address Sex Salary Super_ssn Dno Franklin Jennifer Ramesh T Wong Wallace Narayan 333445555 987654321 666884444 1955-12-08 1941-06-20 1962-09-15 638 Voss, Houston, TX 291 Berry, Bellaire, TX 975 Fire Oak, Humble, TX M F M 40000 43000 38000 888665555 888665555 333445555 5 4 5 Lname Fname Salary Smith Wong Zelaya Wallace Narayan English Jabbar Borg John Franklin Alicia Jennifer Ramesh Joyce Ahmad James 30000 40000 25000 43000 38000 25000 25000 30000 40000 25000 43000 38000 25000 55000 55000 Sex Salary M M F F M M M (c) (b) (a) S K Figure 6.1 Results of SELECT and PROJECT operations. (a) σ(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000) (EMPLOYEE). (b) πLname, Fname, Salary(EMPLOYEE). (c) πSex, Salary(EMPLOYEE). === Page 178 === 6.1 Unary Relational Operations: SELECT and PROJECT 149 selected. All the selected tuples appear in the result of the SELECT operation. The Boolean conditions AND, OR, and NOT have their normal interpretation, as follows: ■(cond1 AND cond2) is TRUE if both (cond1) and (cond2) are TRUE; other- wise, it is FALSE. ■(cond1 OR cond2) is TRUE if either (cond1) or (cond2) or both are TRUE; otherwise, it is FALSE. ■(NOT cond) is TRUE if cond is FALSE; otherwise, it is FALSE. The SELECT operator is unary; that is, it is applied to a single relation. Moreover, the selection operation is applied to each tuple individually; hence, selection condi- tions cannot involve more than one tuple. The degree of the relation resulting from a SELECT operation—its number of attributes—is the same as the degree of R. The number of tuples in the resulting relation is always less than or equal to the number of tuples in R. That is, |σc (R)| ≤|R| for any condition C. The fraction of tuples selected by a selection condition is referred to as the selectivity of the condition. Notice that the SELECT operation is commutative; that is, σ<cond1>(σ<cond2>(R)) = σ<cond2>(σ<cond1>(R)) Hence, a sequence of SELECTs can be applied in any order. In addition, we can always combine a cascade (or sequence) of SELECT operations into a single SELECT operation with a conjunctive (AND) condition; that is, σ<cond1>(σ<cond2>(...(σ<condn>(R)) ...)) = σ<cond1> AND<cond2> AND...AND <condn>(R) In SQL, the SELECT condition is typically specified in the WHERE clause of a query. For example, the following operation: σDno=4 AND Salary>25000 (EMPLOYEE) would correspond to the following SQL query: SELECT * FROM EMPLOYEE WHERE Dno=4 AND Salary>25000; 6.1.2 The PROJECT Operation If we think of a relation as a table, the SELECT operation chooses some of the rows from the table while discarding other rows. The PROJECT operation, on the other hand, selects certain columns from the table and discards the other columns. If we are interested in only certain attributes of a relation, we use the PROJECT operation to project the relation over these attributes only. Therefore, the result of the PROJECT operation can be visualized as a vertical partition of the relation into two relations: one has the needed columns (attributes) and contains the result of the operation, and the other contains the discarded columns. For example, to list each employee’s first and last name and salary, we can use the PROJECT operation as follows: πLname, Fname, Salary(EMPLOYEE) === Page 179 === 150 Chapter 6 The Relational Algebra and Relational Calculus The resulting relation is shown in Figure 6.1(b). The general form of the PROJECT operation is π<attribute list>(R) where π (pi) is the symbol used to represent the PROJECT operation, and <attribute list> is the desired sublist of attributes from the attributes of relation R. Again, notice that R is, in general, a relational algebra expression whose result is a relation, which in the simplest case is just the name of a database relation. The result of the PROJECT operation has only the attributes specified in <attribute list> in the same order as they appear in the list. Hence, its degree is equal to the number of attributes in <attribute list>. If the attribute list includes only nonkey attributes of R, duplicate tuples are likely to occur. The PROJECT operation removes any duplicate tuples, so the result of the PROJECT operation is a set of distinct tuples, and hence a valid relation. This is known as duplicate elimination. For example, consider the following PROJECT operation: πSex, Salary(EMPLOYEE) The result is shown in Figure 6.1(c). Notice that the tuple <‘F’, 25000> appears only once in Figure 6.1(c), even though this combination of values appears twice in the EMPLOYEE relation. Duplicate elimination involves sorting or some other tech- nique to detect duplicates and thus adds more processing. If duplicates are not elim- inated, the result would be a multiset or bag of tuples rather than a set. This was not permitted in the formal relational model, but is allowed in SQL (see Section 4.3). The number of tuples in a relation resulting from a PROJECT operation is always less than or equal to the number of tuples in R. If the projection list is a superkey of R—that is, it includes some key of R—the resulting relation has the same number of tuples as R. Moreover, π<list1> (π<list2>(R)) = π<list1>(R) as long as <list2> contains the attributes in <list1>; otherwise, the left-hand side is an incorrect expression. It is also noteworthy that commutativity does not hold on PROJECT. In SQL, the PROJECT attribute list is specified in the SELECT clause of a query. For example, the following operation: πSex, Salary(EMPLOYEE) would correspond to the following SQL query: SELECT DISTINCT Sex, Salary FROM EMPLOYEE Notice that if we remove the keyword DISTINCT from this SQL query, then dupli- cates will not be eliminated. This option is not available in the formal relational algebra.

--- Chunk 5 ---
=== Page 551 === 520 Chapter 15 Relational Database Design Algorithms and Further Dependencies Step 3 of Algorithm 15.4 involves identifying a key K of R. Algorithm 15.2(a) can be used to identify a key K of R based on the set of given functional dependencies F. Notice that the set of functional dependencies used to determine a key in Algo- rithm 15.2(a) could be either F or G, since they are equivalent. Example 1 of Algorithm 15.4. Consider the following universal relation: U (Emp_ssn, Pno, Esal, Ephone, Dno, Pname, Plocation) Emp_ssn, Esal, and Ephone refer to the Social Security number, salary, and phone number of the employee. Pno, Pname, and Plocation refer to the number, name, and location of the project. Dno is the department number. The following dependencies are present: FD1: Emp_ssn → {Esal, Ephone, Dno} FD2: Pno → { Pname, Plocation} FD3: Emp_ssn, Pno → {Esal, Ephone, Dno, Pname, Plocation} By virtue of FD3, the attribute set {Emp_ssn, Pno} represents a key of the universal relation. Hence F, the set of given FDs, includes {Emp_ssn → Esal, Ephone, Dno; Pno → Pname, Plocation; Emp_ssn, Pno → Esal, Ephone, Dno, Pname, Plocation}. By applying the minimal cover Algorithm 15.2, in step 3 we see that Pno is an extra- neous attribute in Emp_ssn, Pno → Esal, Ephone, Dno. Moreover, Emp_ssn is extrane- ous in Emp_ssn, Pno → Pname, Plocation. Hence the minimal cover consists of FD1 and FD2 only (FD3 being completely redundant) as follows (if we group attributes with the same left-hand side into one FD): Minimal cover G: {Emp_ssn → Esal, Ephone, Dno; Pno → Pname, Plocation} The second step of Algorithm 15.4 produces relations R1 and R2 as: R1 (Emp_ssn, Esal, Ephone, Dno) R2 (Pno, Pname, Plocation) In step 3, we generate a relation corresponding to the key {Emp_ssn, Pno} of U. Hence, the resulting design contains: R1 (Emp_ssn, Esal, Ephone, Dno) R2 (Pno, Pname, Plocation) R3 (Emp_ssn, Pno) This design achieves both the desirable properties of dependency preservation and nonadditive join. Example 2 of Algorithm 15.4 (Case X). Consider the relation schema LOTS1A shown in Figure 14.13(a). Assume that this relation is given as a universal relation U (Property_id, County, Lot#, Area) with the following functional dependencies: === Page 552 === 15.3 Algorithms for Relational Database Schema Design 521 FD1: Property_id → Lot#, County, Area FD2: Lot#, County → Area, Property_id FD3: Area → County These were called FD1, FD2, and FD5 in Figure 14.13(a). The meanings of the above attributes and the implication of the above functional dependencies were explained in Section 14.4.For ease of reference, let us abbreviate the above attributes with the first letter for each and represent the functional dependencies as the set F: { P → LCA, LC → AP, A → C } The universal relation with abbreviated attributes is U (P, C, L, A). If we apply the minimal cover Algorithm 15.2 to F, (in step 2) we first represent the set F as F: {P → L, P → C, P → A, LC → A, LC → P, A → C} In the set F, P → A can be inferred from P → LC and LC → A; hence P → A by tran- sitivity and is therefore redundant. Thus, one possible minimal cover is Minimal cover GX: {P → LC, LC → AP, A → C} In step 2 of Algorithm 15.4, we produce design X (before removing redundant rela- tions) using the above minimal cover as Design X: R1 (P, L, C), R2 (L, C, A, P), and R3 (A, C) In step 4 of the algorithm, we find that R3 is subsumed by R2 (that is, R3 is always a projection of R2 and R1 is a projection of R2 as well). Hence both of those relations are redundant. Thus the 3NF schema that achieves both of the desirable properties is (after removing redundant relations) Design X: R2 (L, C, A, P). or, in other words it is identical to the relation LOTS1A (Property_id, Lot#, County, Area) that we had determined to be in 3NF in Section 14.4.2. Example 2 of Algorithm 15.4 (Case Y). Starting with LOTS1A as the universal relation and with the same given set of functional dependencies, the second step of the minimal cover Algorithm 15.2 produces, as before, F: {P → C, P → A, P → L, LC → A, LC → P, A → C} The FD LC → A may be considered redundant because LC → P and P → A implies LC → A by transitivity. Also, P → C may be considered to be redundant because P → A and A → C implies P → C by transitivity. This gives a different minimal cover as Minimal cover GY: { P → LA, LC → P, A → C } The alternative design Y produced by the algorithm now is Design Y: S1 (P, A, L), S2 (L, C, P), and S3 (A, C) Note that this design has three 3NF relations, none of which can be considered as redundant by the condition in step 4. All FDs in the original set F are preserved. The === Page 553 === 522 Chapter 15 Relational Database Design Algorithms and Further Dependencies reader will notice that of the above three relations, relations S1 and S3 were produced as the BCNF design by the procedure given in Section 14.5 (implying that S2 is redundant in the presence of S1 and S3). However, we cannot eliminate relation S2 from the set of three 3NF relations above since it is not a projection of either S1 or S3. It is easy to see that S2 is a valid and meaningful relation that has the two candidate keys (L, C), and P placed side-by-side. Notice further that S2 preserves the FD LC → P, which is lost if the final design contains only S1 and S3. Design Y therefore remains as one possible final result of applying Algorithm 15.4 to the given universal relation that provides relations in 3NF. The above two variations of applying Algorithm 15.4 to the same universal relation with a given set of FDs have illustrated two things: ■It is possible to generate alternate 3NF designs by starting from the same set of FDs. ■It is conceivable that in some cases the algorithm actually produces relations that satisfy BCNF and may include relations that maintain the dependency preservation property as well. 15.3.2 Nonadditive Join Decomposition into BCNF Schemas The next algorithm decomposes a universal relation schema R = {A1, A2, … , An} into a decomposition D = {R1, R2, … , Rm} such that each Ri is in BCNF and the decomposition D has the lossless join property with respect to F. Algorithm 15.5 utilizes property NJB and claim 2 (preservation of nonadditivity in successive decompositions) to create a nonadditive join decomposition D = {R1, R2, … , Rm} of a universal relation R based on a set of functional dependencies F, such that each Ri in D is in BCNF. Algorithm 15.5. Relational Decomposition into BCNF with Nonadditive Join Property Input: A universal relation R and a set of functional dependencies F on the attributes of R. 1. Set D := {R} ; 2. While there is a relation schema Q in D that is not in BCNF do { choose a relation schema Q in D that is not in BCNF; find a functional dependency X → Y in Q that violates BCNF; replace Q in D by two relation schemas (Q − Y) and (X ∪ Y); } ; Each time through the loop in Algorithm 15.5, we decompose one relation schema Q that is not in BCNF into two relation schemas. According to property NJB for binary decompositions and claim 2, the decomposition D has the nonadditive join property. At the end of the algorithm, all relation schemas in D will be in

--- Chunk 6 ---
=== Page 680 === Scherna llefincl1H;nt (nul IVorrnal 1:"~oTn18 645 Exercise 19.8 Consider the attribute set Ii = ABCDEGH (Lud theFD set F= {A.B·--+ C:, AC --+ B: AD ---4 E, B -----+ D, Be --+ 11, B -!- G}. 1. For each of the following attribute sets, do the following: Cornpute the set of depen- dencies that hold over the set and write down a rninirnal cover. (ii) Narne the strongest nonnal [onn that is not violated by the relation containing these attributes. (iii) De- COlnpose it into a. collection of BCNF relations if it is IH)t in BeNF'. (a) ABC, (b) ABCD, (c) ABCEG, (d) DC:BGII, (e) ACEH 2. vVhich of the following decOIllpositions of R = ABCDEG, with the saIne set of depen- dencies F', is (a) dependency-preserving? (b) lossless-join? (a) {AB, BC, ABDE. EG } (b) {ABC, ACDE, ADG } Exercise 19.9 Let R be decOIllposed into R 1 , R2 , ... , Rn . Let F be a set of FDs on R. 1. Define what it rlleans for F to be pre8erved in the set of decOlllposed relations. 2. Describe a polynomial-tirne algorithm to test dependency-preservation. 3. Projecting the FDs stated over a set of attributes X onto a subset of attributes Y requires that we consider the closure of the FDs. Give an exarnple where considering the closure is irnportant in testing dependency-preservation, that is, considering just the given FDs gives incorrect results. Exercise 19.10 Suppose you are given a relation R(A,B, C,D). For each of the following sets of FDs, assuming they are the only dependencies that hold for R, do the following: (a) Identify the candidate key(s) for R. (b) State whether or not the proposed decOlnposition of R into smaller relations is a good decolllposition and briefly explain why or why not. 1. B --+ C, D --+ A; decornpose into BC and AD. 2. AB -+ C, C -~~ A, C ,--)- D; decompose into A CD and Be. ~~. A -!- BC, C -+ AD; decornpose into ABC and AD. 4. A -!- B, B C, C '-1 D; decornpose into AB and A CD. 5. A --+ B, B -+ C, C -!- D; decOInpose into AB, AD and CD. Exercise 19.11 Consider a relation R that has three a"ttributes ABC. It is decornposed into relations R 1 with attributes AB and R 2 with attributes Be. 1. St<lte the definition of a lossless-join decOlnposition with respect to this exarnple. Answer this question concisely by \-vriting a relational algebra equation involving R, R 1 , and H2. 2. Suppose that B --+--+ C. Is the decorHposition of R into .R! and R2 lossless-join? Reconcile your (l.,nswer with the observation that neither of the FDs HI nR2 ----'> R I nor R I n R2 --+ .H..2 hold, in light <;)f the siInple test offering a necessary and sufficient condition for lossless- join decmnposition into two relations in Section 15.6.1. :3. If you are given the follc}\\ring justa.nees of R 1 a,nd 112, what can you say about the instance of R from which these were obtained? Answer this question by listing tuples that are definitely ill R and tuples that a.re possibly· in R. Instance of RJ. = {(5,l), (6,l)} Instance of R 2 :::::: {(l,8), (1,9)} Can you say that attribute B definitely is or 'is not. a key for R? === Page 681 === 646 CHAPTER 19 Exercise 19.12 Suppose that we have the following four tuples in a relation 5' with three attributes ABC: (1,2,:3), (4,2,:3), (5,3,:3), (5,::~A). \Vhich of the following functional (-+) and rIlultivalued (-+--» dependencies can you infer does not hold over relation S? 1. A -+ 13 2. A _....-} ..._,,-} B 3. Be --,} A 4. BG -+_..~> A 5. 8 -+ C 6. B ~'---'o C Exercise 19.13 Consider a relation R with five attributes A BCDE'. 1. For each of the following instances of R, state whether it violates (a) theFD Be ",,"-, D and (b) the J\fVD Be _..-t--+ D: (a) { } (i.e., mnpty relation) (b) {(0,,2,3,4,5), (2,a,3,5,5)} (c) {(o,,2,3,4,5), (2,0,,3,5,5), (o,,2,3,4,6)} (d) {( a,2)~,4,5), (2,0,,3,4,5), (o,,2,3,6,5)} (e) {(0,,2,3,4,5), (2,0,,3,7,5), (a,2,3,4,6)} (f) {(o,,2,3,4,5), (2,0,,3,4,5), (0,,2,3,6,5), (o,,2,3,6,6)} (g) {(a,2,~3,4,5), (0,,2,:3,6,5), (0,,2,3,6,6), (o,,2,3,4,6)} 2. If each instance for R listed above is legal, what can you say about the FD A -+ B? Exercise 19.14 JDs are lllotivated by the fact that sornetilnes a relation that cannot be decoruposed into two sinaller relations in a lossless-join rnanner can be so deC0111pOsed into three or rnore relations. An exa,rnple is a relation with attributes 8upplier, part, clnd J}Toject, denoted SPJ, with no FDs or l'vlVDs. The JD [Xl {SP, P J, J S} holds. Frorn the JD, the set of relation scheines SP, PJ, and JS is a IORsless-join decornposition of SPJ. Construct an instance of HPJ to illustrate that no two of these schernes suffice. Exercise 19.15 Answer the following questions 1. Prove that the algorithrn shown in Figure 19.4 correctly cornputes the ::l.ttribute closure of the input attribute set X. 2. Describe a linear-tirne (in the size of the set of FI)s, where the size of each FD is the nurnber of attributes involved) algoritlun for finding the attribute closure of a set of attributes with respect to a set of FDs. Prove that your algoritlun correctly COInputes the attribute closure of the input attrilnlte set. Exercise 19.16 Let us say that an 'Fl) )( -_.,} Y is si'mple if Y is a single attribute. 1. Replace the FD AB........, CD l.Jy the srnallest equivalent collection of sirnple FDs. 2. Prove that everyFD X _...crY" in (.'L set of FDs F Cetn be replaced by a set of sirnple F'Ds such that p+ is equal to the closure of the new set of FDs.

--- Chunk 7 ---
=== Page 661 === 626 ACDF-tEand ACDF-t G, CHAPTERt9 Next consider ACDF -+ G, This dependency is irnplied by the following FDs: A -7 B, ABC'D -7 E, and EF -7 G, Therefore, \ve can delete it, Sirnilarly, we can delete A CDF -7 1:7, Next con- sider ABCD -7 E, Since A -7 B holds, we can replace it with ACD _..._~ E, (At this point, the reader should verify that each rernaining FD is rninilnal and required,) Thus, a rninilnal cover for F is the set: A -7 B, ACD -7 E, EF ---7 Ci, and EF --+ H, The preceding exarnple illustrates a general algorithrn for obtaining a rninimal cover of a set }i' of FDs: 1. Put the FDs in a Standard Form: Obtain a collection G of equivalent FDs with a single attribute on the right side (using the decornposition axiolIl), 2. Minimize the Left Side of Each FD: For each FD in G, check each attribute in the left side to see if it can be deleted while preserving equiv- alence to F+, 3. Delete Redundant FDs: Check each reluaining FD in G to see if it can be deleted while preserving equivalence to .F+, Note that the order in which we consider FDs while applying these steps could produce different rninilnal covers; there could be severa'! rninirnal covers for a given set of FDs, lV101'8 irnportant, it is necessary to rniniInize the left sides of F'Ds befoTc checking for redundant FI)s, If these two steps are reversed, the final set of FI)s could still contain senne redundant FDs (i,e., not be a rninirnal cover), as the following exarnple illustrates, LetF be the set of dependencies, each of ""vhich is already in the standard fornl: .A13CTJ -t E',E " ~~ D, A ----;. 13, and A C ----;. I), Observe that none of these FDs is redundant; if \ve checked for redundantFDs first, \ve ""vould get the saIne set of FI)s I?, The left side of il13CIJ }; can be n~l)hiced by ACt\vhile preserving equivalence to 1~"1+, and ,ve \vould stop here if \ve checked for reclunda.ntF'Ds in I? before rnillilnizing the left sides. HO\V8Ver, the set of FDs ""ve 11(lVe is not a Inininlal cover: === Page 662 === Sche17~a Ilefinerncnt and NOTrnal j?OT'lnS ACt .......:;. E,E _..-+ D,A --t B, and AG1 -+ D. ~127 FrOlIl transitivity, the first two FDs irnply the la.",'3t FD, ,v-hich can therefore be deleted while preserving equivalence to 1~1+. The irnportant point to note is that A C---+ D becc)lnes redundant only after we replace ABeD -)- E with AC -)- E. If "ve Ininirnize left sides of FDs first and then cheek for redundantFDs, ,ve are left "vith the first three FDs in the preeeding list,whieh is indeed a Ininirna1 cover for F. Dependency-Preserving Decomposition into 3NJ.1-' Returning to the problenl of obtaining a lossless-join, dependency-preserving decornposition into 3NF relations, let R be a relation with a set [/' of FDs that is a minirnal cover, and let R 1 , R2 , ... , Rn be a lossless-join decolnposition of R. For 1 < i < n, suppose that each Ri is in 3NF and let Fi denote the projection of F onto the attributes of Ri . Do the following: • Identify the set N of dependencies in F that is not preserved, that is, not included in the closure of the union of Fis. • :F'or each FD X ---t A in N, create a relation schelna XA and add it to the decomposition of R. Obviously, every dependency in F is preserved if we replace R by the R'iS plus the schernas of the forn1 XA added in this step. The Ris are given to be in 3NF. We can show that each of the schelnas XA is in 3NF as follows: Since X ----7' A is in the lninirnal cover F, Y ---+ A does not hold for any Y that is a strict subset of X. Therefore, X is (1, key for XA. :F\llrther, if any other dependencies hold over XA, the right side can involve only attributes in X' because A is a single attribute (because X -~ A is an FD in a rninhnal cover). Since X is a key for ..:YA, none of these additional dependencies causes a violation of ~3NF (although they rnight cause a violation of BCNF). As an optilYlization, if the set N contains several FI)swith the saIne left side, say, X -~~.-t ..41, X -t A 2 , , ..X- ..+ /In , we can replace thern \vith (.I., single equivalent FD X -t AI ..I4·n . Therefore, \ve produce one relation scherna ..X' ..14 1 ... /In , instead of several schernas XA 1 , .... ~X'"An, \vhich is gener- ally preferable. (~onsider the Contracts relation vvith attrilnltes C:SJDPQV etnel FI)s JP -j> C:, 81)--4 P. and J ....-» S. If \ve decolnpose (}SJIJPe) V into SDIJ and C}SJl)(JV, then 8DP is in BCNF, but C\'1J1)(2 V is not ev(~n in :3NI;'. So \ve dec.olupose it further into JS and C 1JDe2 V. rrhe relation schcrnas 19IJ.P, .I8, Etnel C7JDQVare in ~3NF (in fact, in BCNF) 1 and the decoInposition is lossless-join. lIowever,

--- Chunk 8 ---
=== Page 272 === 8.1 Unary Relational Operations: SELECT and PROJECT 241 Chapters 6 and 7 are based on the tuple relational calculus. The relational calculus is a formal language, based on the branch of mathematical logic called predicate calculus.2 In tuple relational calculus, variables range over tuples, whereas in domain relational calculus, variables range over the domains (values) of attributes. In Appendix C we give an overview of the Query-By-Example (QBE) language, which is a graphical user-friendly relational language based on domain relational calculus. Section 8.8 summarizes the chapter. For the reader who is interested in a less detailed introduction to formal relational languages, Sections 8.4, 8.6, and 8.7 may be skipped. 8.1 Unary Relational Operations: SELECT and PROJECT 8.1.1 The SELECT Operation The SELECT operation is used to choose a subset of the tuples from a relation that satisfies a selection condition.3 We can consider the SELECT operation to be a filter that keeps only those tuples that satisfy a qualifying condition. Alternatively, we can consider the SELECT operation to restrict the tuples in a relation to only those tuples that satisfy the condition. The SELECT operation can also be visualized as a horizon- tal partition of the relation into two sets of tuples—those tuples that satisfy the con- dition and are selected, and those tuples that do not satisfy the condition and are filtered out. For example, to select the EMPLOYEE tuples whose department is 4, or those whose salary is greater than $30,000, we can individually specify each of these two conditions with a SELECT operation as follows: σDno=4(EMPLOYEE) σSalary>30000(EMPLOYEE) In general, the SELECT operation is denoted by σ<selection condition>(R) where the symbol σ (sigma) is used to denote the SELECT operator and the selec- tion condition is a Boolean expression (condition) specified on the attributes of relation R. Notice that R is generally a relational algebra expression whose result is a relation—the simplest such expression is just the name of a database relation. The relation resulting from the SELECT operation has the same attributes as R. The Boolean expression specified in <selection condition> is made up of a number of clauses of the form <attribute name> <comparison op> <constant value> 2In this chapter no familiarity with first-order predicate calculus—which deals with quantified variables and values—is assumed. 3The SELECT operation is different from the SELECT clause of SQL. The SELECT operation chooses tuples from a table, and is sometimes called a RESTRICT or FILTER operation. === Page 273 === 242 Chapter 8 The Relational Algebra and Relational Calculus or <attribute name> <comparison op> <attribute name> where <attribute name> is the name of an attribute of R, <comparison op> is nor- mally one of the operators {=, <, ≤, >, ≥, ≠}, and <constant value> is a constant value from the attribute domain. Clauses can be connected by the standard Boolean operators and, or, and not to form a general selection condition. For example, to select the tuples for all employees who either work in department 4 and make over $25,000 per year, or work in department 5 and make over $30,000, we can specify the following SELECT operation: σ(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000)(EMPLOYEE) The result is shown in Figure 8.1(a). Notice that all the comparison operators in the set {=, <, ≤, >, ≥, ≠} can apply to attributes whose domains are ordered values, such as numeric or date domains. Domains of strings of characters are also considered to be ordered based on the col- lating sequence of the characters. If the domain of an attribute is a set of unordered values, then only the comparison operators in the set {=, ≠} can be used. An exam- ple of an unordered domain is the domain Color = { ‘red’, ‘blue’, ‘green’, ‘white’, ‘yellow’, …}, where no order is specified among the various colors. Some domains allow additional types of comparison operators; for example, a domain of character strings may allow the comparison operator SUBSTRING_OF. Fname Minit Lname Ssn Bdate Address Sex Salary Super_ssn Dno Franklin Jennifer Ramesh T Wong Wallace Narayan 333445555 987654321 666884444 1955-12-08 1941-06-20 1962-09-15 638 Voss, Houston, TX 291 Berry, Bellaire, TX 975 Fire Oak, Humble, TX M F M 40000 43000 38000 888665555 888665555 333445555 5 4 5 Lname Fname Salary Smith Wong Zelaya Wallace Narayan English Jabbar Borg John Franklin Alicia Jennifer Ramesh Joyce Ahmad James 30000 40000 25000 43000 38000 25000 25000 30000 40000 25000 43000 38000 25000 55000 55000 Sex Salary M M F F M M M (c) (b) (a) S K Figure 8.1 Results of SELECT and PROJECT operations. (a) σ(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000) (EMPLOYEE). (b) πLname, Fname, Salary(EMPLOYEE). (c) πSex, Salary(EMPLOYEE). === Page 274 === 8.1 Unary Relational Operations: SELECT and PROJECT 243 In general, the result of a SELECT operation can be determined as follows. The <selection condition> is applied independently to each individual tuple t in R. This is done by substituting each occurrence of an attribute Ai in the selection condition with its value in the tuple t[Ai]. If the condition evaluates to TRUE, then tuple t is selected. All the selected tuples appear in the result of the SELECT operation. The Boolean conditions AND, OR, and NOT have their normal interpretation, as follows: ■(cond1 AND cond2) is TRUE if both (cond1) and (cond2) are TRUE; other- wise, it is FALSE. ■(cond1 OR cond2) is TRUE if either (cond1) or (cond2) or both are TRUE; otherwise, it is FALSE. ■(NOT cond) is TRUE if cond is FALSE; otherwise, it is FALSE. The SELECT operator is unary; that is, it is applied to a single relation. Moreover, the selection operation is applied to each tuple individually; hence, selection condi- tions cannot involve more than one tuple. The degree of the relation resulting from a SELECT operation—its number of attributes—is the same as the degree of R. The number of tuples in the resulting relation is always less than or equal to the number of tuples in R. That is, |σc (R)| ≤ |R| for any condition C. The fraction of tuples selected by a selection condition is referred to as the selectivity of the condition. Notice that the SELECT operation is commutative; that is, σ<cond1>(σ<cond2>(R)) = σ<cond2>(σ<cond1>(R)) Hence, a sequence of SELECTs can be applied in any order. In addition, we can always combine a cascade (or sequence) of SELECT operations into a single SELECT operation with a conjunctive (AND) condition; that is, σ<cond1>(σ<cond2>(... (σ<condn>(R)) ...)) = σ<cond1> AND<cond2> AND...AND <condn>(R) In SQL, the SELECT condition is typically specified in the WHERE clause of a query. For example, the following operation: σDno=4 AND Salary>25000 (EMPLOYEE) would correspond to the following SQL query: SELECT * FROM EMPLOYEE WHERE Dno=4 AND Salary>25000; 8.1.2 The PROJECT Operation If we think of a relation as a table, the SELECT operation chooses some of the rows from the table while discarding other rows. The PROJECT operation, on the other hand, selects certain columns from the table and discards the other columns. If we are interested in only certain attributes of a relation, we use the PROJECT operation to project the relation over these attributes only. Therefore, the result of the PROJECT operation can be visualized as a vertical partition of the relation into two relations:

==== Top 8 Chunks for Query: - normalization ====

--- Chunk 1 ---
=== Page 506 === 14.3 Normal Forms Based on Primary Keys 475 this section on the first three normal forms for relation schemas and the intuition behind them, and we discuss how they were developed historically. More general definitions of these normal forms, which take into account all candidate keys of a relation rather than just the primary key, are deferred to Section 14.4. We start by informally discussing normal forms and the motivation behind their development, as well as reviewing some definitions from Chapter 3 that are needed here. Then we discuss the first normal form (1NF) in Section 14.3.4, and we present the definitions of second normal form (2NF) and third normal form (3NF), which are based on primary keys, in Sections 14.3.5 and 14.3.6, respectively. 14.3.1 Normalization of Relations The normalization process, as first proposed by Codd (1972a), takes a relation schema through a series of tests to certify whether it satisfies a certain normal form. The process, which proceeds in a top-down fashion by evaluating each relation against the criteria for normal forms and decomposing relations as necessary, can thus be considered as relational design by analysis. Initially, Codd proposed three normal forms, which he called first, second, and third normal form. A stronger definition of 3NF—called Boyce-Codd normal form (BCNF)—was proposed later by Boyce and Codd. All these normal forms are based on a single analytical tool: the functional dependencies among the attributes of a relation. Later, a fourth normal form (4NF) and a fifth normal form (5NF) were proposed, based on the concepts of multivalued dependencies and join dependencies, respectively; these are briefly dis- cussed in Sections 14.6 and 14.7. Normalization of data can be considered a process of analyzing the given relation schemas based on their FDs and primary keys to achieve the desirable properties of (1) minimizing redundancy and (2) minimizing the insertion, deletion, and update anomalies discussed in Section 14.1.2. It can be considered as a “filtering” or “purifi- cation” process to make the design have successively better quality. An unsatisfactory relation schema that does not meet the condition for a normal form—the normal form test—is decomposed into smaller relation schemas that contain a subset of the attributes and meet the test that was otherwise not met by the original relation. Thus, the normalization procedure provides database designers with the following: ■A formal framework for analyzing relation schemas based on their keys and on the functional dependencies among their attributes ■A series of normal form tests that can be carried out on individual relation schemas so that the relational database can be normalized to any desired degree Definition. The normal form of a relation refers to the highest normal form condition that it meets, and hence indicates the degree to which it has been normalized. Normal forms, when considered in isolation from other factors, do not guarantee a good database design. It is generally not sufficient to check separately that each === Page 507 === 476 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases relation schema in the database is, say, in BCNF or 3NF. Rather, the process of nor- malization through decomposition must also confirm the existence of additional properties that the relational schemas, taken together, should possess. These would include two properties: ■The nonadditive join or lossless join property, which guarantees that the spurious tuple generation problem discussed in Section 14.1.4 does not occur with respect to the relation schemas created after decomposition ■The dependency preservation property, which ensures that each functional dependency is represented in some individual relation resulting after decomposition The nonadditive join property is extremely critical and must be achieved at any cost, whereas the dependency preservation property, although desirable, is some- times sacrificed, as we discuss in Section 15.2.2. We defer the discussion of the for- mal concepts and techniques that guarantee the above two properties to Chapter 15. 14.3.2 Practical Use of Normal Forms Most practical design projects in commercial and governmental environment acquire existing designs of databases from previous designs, from designs in legacy models, or from existing files. They are certainly interested in assuring that the designs are good quality and sustainable over long periods of time. Existing designs are evaluated by applying the tests for normal forms, and normalization is carried out in practice so that the resulting designs are of high quality and meet the desirable properties stated previously. Although several higher normal forms have been defined, such as the 4NF and 5NF that we discuss in Sections 14.6 and 14.7, the practical utility of these normal forms becomes questionable. The reason is that the constraints on which they are based are rare and hard for the database designers and users to understand or to detect. Designers and users must either already know them or discover them as a part of the business. Thus, database design as practiced in industry today pays particular attention to normalization only up to 3NF, BCNF, or at most 4NF. Another point worth noting is that the database designers need not normalize to the highest possible normal form. Relations may be left in a lower normalization status, such as 2NF, for performance reasons, such as those discussed at the end of Sec- tion 14.1.2. Doing so incurs the corresponding penalties of dealing with the anomalies. Definition. Denormalization is the process of storing the join of higher nor- mal form relations as a base relation, which is in a lower normal form. 14.3.3 Definitions of Keys and Attributes Participating in Keys Before proceeding further, let’s look again at the definitions of keys of a relation schema from Chapter 3. Definition. A superkey of a relation schema R = {A1, A2, … , An} is a set of attri- butes S ⊆ R with the property that no two tuples t1 and t2 in any legal relation state r of R will have t1[S] = t2[S]. A key K is a superkey with the additional property that removal of any attribute from K will cause K not to be a superkey anymore.

--- Chunk 2 ---
=== Page 546 === 15.3 Normal Forms Based on Primary Keys 517 this section on the first three normal forms for relation schemas and the intuition behind them, and discuss how they were developed historically. More general defi- nitions of these normal forms, which take into account all candidate keys of a rela- tion rather than just the primary key, are deferred to Section 15.4. We start by informally discussing normal forms and the motivation behind their development, as well as reviewing some definitions from Chapter 3 that are needed here. Then we discuss the first normal form (1NF) in Section 15.3.4, and present the definitions of second normal form (2NF) and third normal form (3NF), which are based on primary keys, in Sections 15.3.5 and 15.3.6, respectively. 15.3.1 Normalization of Relations The normalization process, as first proposed by Codd (1972a), takes a relation schema through a series of tests to certify whether it satisfies a certain normal form. The process, which proceeds in a top-down fashion by evaluating each relation against the criteria for normal forms and decomposing relations as necessary, can thus be considered as relational design by analysis. Initially, Codd proposed three normal forms, which he called first, second, and third normal form. A stronger def- inition of 3NF—called Boyce-Codd normal form (BCNF)—was proposed later by Boyce and Codd. All these normal forms are based on a single analytical tool: the functional dependencies among the attributes of a relation. Later, a fourth normal form (4NF) and a fifth normal form (5NF) were proposed, based on the concepts of multivalued dependencies and join dependencies, respectively; these are briefly dis- cussed in Sections 15.6 and 15.7. Normalization of data can be considered a process of analyzing the given relation schemas based on their FDs and primary keys to achieve the desirable properties of (1) minimizing redundancy and (2) minimizing the insertion, deletion, and update anomalies discussed in Section 15.1.2. It can be considered as a “filtering”or “purifi- cation” process to make the design have successively better quality. Unsatisfactory relation schemas that do not meet certain conditions—the normal form tests—are decomposed into smaller relation schemas that meet the tests and hence possess the desirable properties. Thus, the normalization procedure provides database design- ers with the following: ■A formal framework for analyzing relation schemas based on their keys and on the functional dependencies among their attributes ■A series of normal form tests that can be carried out on individual relation schemas so that the relational database can be normalized to any desired degree Definition. The normal form of a relation refers to the highest normal form condition that it meets, and hence indicates the degree to which it has been nor- malized. Normal forms, when considered in isolation from other factors, do not guarantee a good database design. It is generally not sufficient to check separately that each === Page 547 === 518 Chapter 15 Basics of Functional Dependencies and Normalization for Relational Databases relation schema in the database is, say, in BCNF or 3NF. Rather, the process of nor- malization through decomposition must also confirm the existence of additional properties that the relational schemas, taken together, should possess. These would include two properties: ■The nonadditive join or lossless join property, which guarantees that the spurious tuple generation problem discussed in Section 15.1.4 does not occur with respect to the relation schemas created after decomposition. ■The dependency preservation property, which ensures that each functional dependency is represented in some individual relation resulting after decomposition. The nonadditive join property is extremely critical and must be achieved at any cost, whereas the dependency preservation property, although desirable, is some- times sacrificed, as we discuss in Section 16.1.2.We defer the presentation of the for- mal concepts and techniques that guarantee the above two properties to Chapter 16. 15.3.2 Practical Use of Normal Forms Most practical design projects acquire existing designs of databases from previous designs, designs in legacy models, or from existing files. Normalization is carried out in practice so that the resulting designs are of high quality and meet the desir- able properties stated previously. Although several higher normal forms have been defined, such as the 4NF and 5NF that we discuss in Sections 15.6 and 15.7, the practical utility of these normal forms becomes questionable when the constraints on which they are based are rare, and hard to understand or to detect by the data- base designers and users who must discover these constraints. Thus, database design as practiced in industry today pays particular attention to normalization only up to 3NF, BCNF, or at most 4NF. Another point worth noting is that the database designers need not normalize to the highest possible normal form. Relations may be left in a lower normalization status, such as 2NF, for performance reasons, such as those discussed at the end of Section 15.1.2. Doing so incurs the corresponding penalties of dealing with the anomalies. Definition. Denormalization is the process of storing the join of higher nor- mal form relations as a base relation, which is in a lower normal form. 15.3.3 Definitions of Keys and Attributes Participating in Keys Before proceeding further, let’s look again at the definitions of keys of a relation schema from Chapter 3. Definition. A superkey of a relation schema R = {A1, A2, ... , An} is a set of attributes S ⊆R with the property that no two tuples t1 and t2 in any legal rela- tion state r of R will have t1[S] = t2[S]. A key K is a superkey with the additional property that removal of any attribute from K will cause K not to be a superkey any more.

--- Chunk 3 ---
=== Page 553 === 524 Chapter 15 Basics of Functional Dependencies and Normalization for Relational Databases Ssn EMP_PROJ (a) (b) FD1 FD2 FD3 2NF Normalization Pnumber Hours Ename Pname Plocation Ssn EP1 FD1 Pnumber Hours Ename Ssn ED1 Bdate Address Dnumber Ssn EP2 FD2 Ename Pnumber EP3 FD3 Pname Plocation Ename Ssn EMP_DEPT Bdate Address Dnumber Dname Dmgr_ssn Dnumber ED2 Dname Dmgr_ssn 3NF Normalization Figure 15.11 Normalizing into 2NF and 3NF. (a) Normalizing EMP_PROJ into 2NF relations. (b) Normalizing EMP_DEPT into 3NF relations. dependencies Ssn →Dnumber and Dnumber →Dmgr_ssn hold and Dnumber is nei- ther a key itself nor a subset of the key of EMP_DEPT. Intuitively, we can see that the dependency of Dmgr_ssn on Dnumber is undesirable in EMP_DEPT since Dnumber is not a key of EMP_DEPT. Definition. According to Codd’s original definition, a relation schema R is in 3NF if it satisfies 2NF and no nonprime attribute of R is transitively dependent on the primary key. The relation schema EMP_DEPT in Figure 15.3(a) is in 2NF, since no partial depen- dencies on a key exist. However, EMP_DEPT is not in 3NF because of the transitive dependency of Dmgr_ssn (and also Dname) on Ssn via Dnumber. We can normalize === Page 554 === 15.4 General Definitions of Second and Third Normal Forms 525 Table 15.1 Summary of Normal Forms Based on Primary Keys and Corresponding Normalization Normal Form Test Remedy (Normalization) First (1NF) Relation should have no multivalued attributes or nested relations. Form new relations for each multivalued attribute or nested relation. Second (2NF) For relations where primary key con- tains multiple attributes, no nonkey attribute should be functionally dependent on a part of the primary key. Decompose and set up a new relation for each partial key with its dependent attrib- ute(s). Make sure to keep a relation with the original primary key and any attributes that are fully functionally dependent on it. Third (3NF) Relation should not have a nonkey attribute functionally determined by another nonkey attribute (or by a set of nonkey attributes). That is, there should be no transitive dependency of a non- key attribute on the primary key. Decompose and set up a relation that includes the nonkey attribute(s) that func- tionally determine(s) other nonkey attrib- ute(s). EMP_DEPT by decomposing it into the two 3NF relation schemas ED1 and ED2 shown in Figure 15.11(b). Intuitively, we see that ED1 and ED2 represent independ- ent entity facts about employees and departments. A NATURAL JOIN operation on ED1 and ED2 will recover the original relation EMP_DEPT without generating spu- rious tuples. Intuitively, we can see that any functional dependency in which the left-hand side is part (a proper subset) of the primary key, or any functional dependency in which the left-hand side is a nonkey attribute, is a problematic FD. 2NF and 3NF normal- ization remove these problem FDs by decomposing the original relation into new relations. In terms of the normalization process, it is not necessary to remove the partial dependencies before the transitive dependencies, but historically, 3NF has been defined with the assumption that a relation is tested for 2NF first before it is tested for 3NF. Table 15.1 informally summarizes the three normal forms based on primary keys, the tests used in each case, and the corresponding remedy or normal- ization performed to achieve the normal form. 15.4 General Definitions of Second and Third Normal Forms In general, we want to design our relation schemas so that they have neither partial nor transitive dependencies because these types of dependencies cause the update anomalies discussed in Section 15.1.2. The steps for normalization into 3NF rela- tions that we have discussed so far disallow partial and transitive dependencies on the primary key. The normalization procedure described so far is useful for analysis in practical situations for a given database where primary keys have already been defined. These definitions, however, do not take other candidate keys of a relation, if

--- Chunk 4 ---
=== Page 515 === 484 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases the primary key. The normalization procedure described so far is useful for analysis in practical situations for a given database where primary keys have already been defined. These definitions, however, do not take other candidate keys of a relation, if any, into account. In this section we give the more general definitions of 2NF and 3NF that take all candidate keys of a relation into account. Notice that this does not affect the definition of 1NF since it is independent of keys and functional depen- dencies. As a general definition of prime attribute, an attribute that is part of any candidate key will be considered as prime. Partial and full functional dependencies and transitive dependencies will now be considered with respect to all candidate keys of a relation. 14.4.1 General Definition of Second Normal Form Definition. A relation schema R is in second normal form (2NF) if every nonprime attribute A in R is not partially dependent on any key of R.12 The test for 2NF involves testing for functional dependencies whose left-hand side attributes are part of the primary key. If the primary key contains a single attribute, the test need not be applied at all. Consider the relation schema LOTS shown in Figure 14.12(a), which describes parcels of land for sale in various counties of a state. Suppose that there are two candidate keys: Property_id# and {County_name, Lot#}; that is, lot numbers are unique only within each county, but Property_id# numbers are unique across counties for the entire state. Table 14.1 Summary of Normal Forms Based on Primary Keys and Corresponding Normalization Normal Form Test Remedy (Normalization) First (1NF) Relation should have no multivalued attributes or nested relations. Form new relations for each multivalued attribute or nested relation. Second (2NF) For relations where primary key contains multiple attributes, no nonkey attribute should be functionally dependent on a part of the primary key. Decompose and set up a new relation for each partial key with its dependent attribute(s). Make sure to keep a relation with the original primary key and any attributes that are fully functionally dependent on it. Third (3NF) Relation should not have a nonkey attribute functionally determined by another nonkey attribute (or by a set of nonkey attributes). That is, there should be no transitive dependency of a nonkey attribute on the primary key. Decompose and set up a relation that includes the nonkey attribute(s) that functionally determine(s) other nonkey attribute(s). 12This definition can be restated as follows: A relation schema R is in 2NF if every nonprime attribute A in R is fully functionally dependent on every key of R. === Page 516 === 14.4 General Definitions of Second and Third Normal Forms 485 Property_id# LOTS (a) FD1 FD2 FD3 FD4 County_name Lot# Area Price Tax_rate Property_id# LOTS1 (b) FD1 FD2 FD4 County_name Lot# Area Price (c) (d) Property_id# LOTS1A FD1 FD2 County_name Lot# Area LOTS2 FD3 County_name Tax_rate LOTS1B FD4 Area Price LOTS 1NF LOTS1 LOTS1A LOTS1B LOTS2 2NF LOTS2 3NF Candidate Key Figure 14.12 Normalization into 2NF and 3NF. (a) The LOTS relation with its functional dependencies FD1 through FD4. (b) Decomposing into the 2NF relations LOTS1 and LOTS2. (c) Decomposing LOTS1 into the 3NF relations LOTS1A and LOTS1B. (d) Progressive normalization of LOTS into a 3NF design. === Page 517 === 486 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases Based on the two candidate keys Property_id# and {County_name, Lot#}, the func- tional dependencies FD1 and FD2 in Figure 14.12(a) hold. We choose Property_id# as the primary key, so it is underlined in Figure 14.12(a), but no special consider- ation will be given to this key over the other candidate key. Suppose that the follow- ing two additional functional dependencies hold in LOTS: FD3: County_name → Tax_rate FD4: Area → Price In words, the dependency FD3 says that the tax rate is fixed for a given county (does not vary lot by lot within the same county), whereas FD4 says that the price of a lot is determined by its area regardless of which county it is in. (Assume that this is the price of the lot for tax purposes.) The LOTS relation schema violates the general definition of 2NF because Tax_rate is partially dependent on the candidate key {County_name, Lot#}, due to FD3. To nor- malize LOTS into 2NF, we decompose it into the two relations LOTS1 and LOTS2, shown in Figure 14.12(b). We construct LOTS1 by removing the attribute Tax_rate that violates 2NF from LOTS and placing it with County_name (the left-hand side of FD3 that causes the partial dependency) into another relation LOTS2. Both LOTS1 and LOTS2 are in 2NF. Notice that FD4 does not violate 2NF and is carried over to LOTS1. 14.4.2 General Definition of Third Normal Form Definition. A relation schema R is in third normal form (3NF) if, whenever a nontrivial functional dependency X → A holds in R, either (a) X is a superkey of R, or (b) A is a prime attribute of R.13 According to this definition, LOTS2 (Figure 14.12(b)) is in 3NF. However, FD4 in LOTS1 violates 3NF because Area is not a superkey and Price is not a prime attribute in LOTS1. To normalize LOTS1 into 3NF, we decompose it into the relation sche- mas LOTS1A and LOTS1B shown in Figure 14.12(c). We construct LOTS1A by removing the attribute Price that violates 3NF from LOTS1 and placing it with Area (the left-hand side of FD4 that causes the transitive dependency) into another rela- tion LOTS1B. Both LOTS1A and LOTS1B are in 3NF. Two points are worth noting about this example and the general definition of 3NF: ■LOTS1 violates 3NF because Price is transitively dependent on each of the candidate keys of LOTS1 via the nonprime attribute Area. ■This general definition can be applied directly to test whether a relation schema is in 3NF; it does not have to go through 2NF first. In other words, if a relation passes the general 3NF test, then it automatically passes the 2NF test. 13Note that based on inferred f.d.’s (which are discussed in Section 15.1), the f.d. Y → YA also holds whenever Y → A is true. Therefore, a slightly better way of saying this statement is that {A-X} is a prime attribute of R. === Page 518 === 14.5 Boyce-Codd Normal Form 487 If we apply the above 3NF definition to LOTS with the dependencies FD1 through FD4, we find that both FD3 and FD4 violate 3NF by the general definition above because the LHS County_name in FD3 is not a superkey. Therefore, we could decompose LOTS into LOTS1A, LOTS1B, and LOTS2 directly. Hence, the transitive and partial dependencies that violate 3NF can be removed in any order. 14.4.3 Interpreting the General Definition of Third Normal Form A relation schema R violates the general definition of 3NF if a functional depen- dency X → A holds in R that meets either of the two conditions, namely (a) and (b). The first condition “catches” two types of problematic dependencies: ■A nonprime attribute determines another nonprime attribute. Here we typi- cally have a transitive dependency that violates 3NF. ■A proper subset of a key of R functionally determines a nonprime attribute. Here we have a partial dependency that violates 2NF. Thus, condition (a) alone addresses the problematic dependencies that were causes for second and third normalization as we discussed. Therefore, we can state a general alternative definition of 3NF as follows: Alternative Definition. A relation schema R is in 3NF if every nonprime attribute of R meets both of the following conditions: ■It is fully functionally dependent on every key of R. ■It is nontransitively dependent on every key of R. However, note the clause (b) in the general definition of 3NF. It allows certain func- tional dependencies to slip through or escape in that they are OK with the 3NF definition and hence are not “caught” by the 3NF definition even though they may be potentially problematic. The Boyce-Codd normal form “catches” these depen- dencies in that it does not allow them. We discuss that normal form next. 14.5 Boyce-Codd Normal Form Boyce-Codd normal form (BCNF) was proposed as a simpler form of 3NF, but it was found to be stricter than 3NF. That is, every relation in BCNF is also in 3NF; however, a relation in 3NF is not necessarily in BCNF. We pointed out in the last subsection that although 3NF allows functional dependencies that conform to the clause (b) in the 3NF definition, BCNF disallows them and hence is a stricter defini- tion of a normal form. Intuitively, we can see the need for a stronger normal form than 3NF by going back to the LOTS relation schema in Figure 14.12(a) with its four functional dependencies FD1 through FD4. Suppose that we have thousands of lots in the relation but the lots are from only two counties: DeKalb and Fulton. Suppose also that lot sizes in DeKalb County are only 0.5, 0.6, 0.7, 0.8, 0.9, and 1.0 acres, whereas lot sizes in Fulton County

--- Chunk 5 ---
=== Page 519 === 488 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases are restricted to 1.1, 1.2, … , 1.9, and 2.0 acres. In such a situation we would have the additional functional dependency FD5: Area → County_name. If we add this to the other dependencies, the relation schema LOTS1A still is in 3NF because this f.d. conforms to clause (b) in the general definition of 3NF, County_name being a prime attribute. The area of a lot that determines the county, as specified by FD5, can be represented by 16 tuples in a separate relation R(Area, County_name), since there are only 16 pos- sible Area values (see Figure 14.13). This representation reduces the redundancy of repeating the same information in the thousands of LOTS1A tuples. BCNF is a stronger normal form that would disallow LOTS1A and suggest the need for decom- posing it. Definition. A relation schema R is in BCNF if whenever a nontrivial functional dependency X → A holds in R, then X is a superkey of R. The formal definition of BCNF differs from the definition of 3NF in that clause (b) of 3NF, which allows f.d.’s having the RHS as a prime attribute, is absent from BCNF. That makes BCNF a stronger normal form compared to 3NF. In our exam- ple, FD5 violates BCNF in LOTS1A because Area is not a superkey of LOTS1A. We can decompose LOTS1A into two BCNF relations LOTS1AX and LOTS1AY, shown in Figure 14.13(a). This decomposition loses the functional dependency FD2 because its attributes no longer coexist in the same relation after decomposition. In practice, most relation schemas that are in 3NF are also in BCNF. Only if there exists some f.d. X → A that holds in a relation schema R with X not being a superkey Property_id# LOTS1A (a) (b) FD1 FD2 FD1 FD2 FD5 BCNF Normalization County_name Lot# Area Property_id# LOTS1AX Area Lot# A R B C Area LOTS1AY County_name Figure 14.13 Boyce-Codd normal form. (a) BCNF normalization of LOTS1A with the functional dependency FD2 being lost in the decomposition. (b) A schematic relation with FDs; it is in 3NF, but not in BCNF due to the f.d. C → B. === Page 520 === 14.5 Boyce-Codd Normal Form 489 and A being a prime attribute will R be in 3NF but not in BCNF. The relation schema R shown in Figure 14.13(b) illustrates the general case of such a relation. Such an f.d. leads to potential redundancy of data, as we illustrated above in case of FD5: Area → County_name.in LOTS1A relation. Ideally, relational database design should strive to achieve BCNF or 3NF for every relation schema. Achieving the normal- ization status of just 1NF or 2NF is not considered adequate, since both were developed historically to be intermediate normal forms as stepping stones to 3NF and BCNF. 14.5.1 Decomposition of Relations not in BCNF As another example, consider Figure 14.14, which shows a relation TEACH with the following dependencies: FD1: {Student, Course} → Instructor FD2:14 Instructor → Course Note that {Student, Course} is a candidate key for this relation and that the depen- dencies shown follow the pattern in Figure 14.13(b), with Student as A, Course as B, and Instructor as C. Hence this relation is in 3NF but not BCNF. Decomposition of this relation schema into two schemas is not straightforward because it may be decomposed into one of the three following possible pairs: 1. R1 (Student, Instructor) and R2(Student, Course) 2. R1 (Course, Instructor) and R2(Course, Student) 3. R1 (Instructor, Course) and R2(Instructor, Student) All three decompositions lose the functional dependency FD1. The question then becomes: Which of the above three is a desirable decomposition? As we pointed out earlier (Section 14.3.1), we strive to meet two properties of decomposition during 14This dependency means that each instructor teaches one course is a constraint for this application. TEACH Student Narayan Smith Smith Smith Mark Navathe Ammar Schulman Operating Systems Database Database Theory Wallace Wallace Wong Zelaya Mark Ahamad Omiecinski Navathe Database Database Operating Systems Database Course Instructor Narayan Operating Systems Ammar Figure 14.14 A relation TEACH that is in 3NF but not BCNF. === Page 521 === 490 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases the normalization process: the nonadditive join property and the functional depen- dency preservation property. We are not able to meet the functional dependency preservation for any of the above BCNF decompositions as seen above; but we must meet the nonadditive join property. A simple test comes in handy to test the binary decomposition of a relation into two relations: NJB (Nonadditive Join Test for Binary Decompositions). A decomposition D = {R1, R2} of R has the lossless (nonadditive) join property with respect to a set of functional dependencies F on R if and only if either ■The FD ((R1 ∩ R2) → (R1 − R2)) is in F+15, or ■The FD ((R1 ∩ R2) → (R2 − R1)) is in F+ If we apply this test to the above three decompositions, we find that only the third decomposition meets the test. In the third decomposition, the R1 ∩ R2 for the above test is Instructor and R1 − R2 is Course. Because Instructor → Course, the NJB test is satisfied and the decomposition is nonadditive. (It is left as an exercise for the reader to show that the first two decompositions do not meet the NJB test.) Hence, the proper decomposition of TEACH into BCNF relations is: TEACH1 (Instructor, Course) and TEACH2 (Instructor, Student) We make sure that we meet this property, because nonadditive decomposition is a must during normalization. You should verify that this property holds with respect to our informal successive normalization examples in Sections 14.3 and 14.4 and also by the decomposition of LOTS1A into two BCNF relations LOTS1AX and LOTS1AY. In general, a relation R not in BCNF can be decomposed so as to meet the nonaddi- tive join property by the following procedure.16 It decomposes R successively into a set of relations that are in BCNF: Let R be the relation not in BCNF, let X ⊆ R, and let X → A be the FD that causes a violation of BCNF. R may be decomposed into two relations: R –A XA If either R –A or XA. is not in BCNF, repeat the process. The reader should verify that if we applied the above procedure to LOTS1A, we obtain relations LOTS1AX and LOTS1AY as before. Similarly, applying this proce- dure to TEACH results in relations TEACH1 and TEACH2 15The notation F+ refers to the cover of the set of functional dependencies and includes all f.d.’s implied by F. It is discussed in detail in Section 15.1. Here, it is enough to make sure that one of the two f.d.’s actually holds for the nonadditive decomposition into R1 and R2 to pass this test. 16Note that this procedure is based on Algorithm 15.5 from Chapter 15 for producing BCNF schemas by decomposition of a universal schema.

--- Chunk 6 ---
=== Page 513 === 482 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases 1NF but is not in 2NF. The nonprime attribute Ename violates 2NF because of FD2, as do the nonprime attributes Pname and Plocation because of FD3. Each of the func- tional dependencies FD2 and FD3 violates 2NF because Ename can be functionally determined by only Ssn, and both Pname and Plocation can be functionally deter- mined by only Pnumber. Attributes Ssn and Pnumber are a part of the primary key {Ssn, Pnumber} of EMP_PROJ, thus violating the 2NF test. If a relation schema is not in 2NF, it can be second normalized or 2NF normalized into a number of 2NF relations in which nonprime attributes are associated only with the part of the primary key on which they are fully functionally dependent. Therefore, the functional dependencies FD1, FD2, and FD3 in Figure 14.3(b) lead to the decomposition of EMP_PROJ into the three relation schemas EP1, EP2, and EP3 shown in Figure 14.11(a), each of which is in 2NF. Ssn EMP_PROJ (a) (b) FD1 FD2 FD3 2NF Normalization Pnumber Hours Ename Pname Plocation Ssn EP1 FD1 Pnumber Hours Ename Ssn ED1 Bdate Address Dnumber Ssn EP2 FD2 Ename Pnumber EP3 FD3 Pname Plocation Ename Ssn EMP_DEPT Bdate Address Dnumber Dname Dmgr_ssn Dnumber ED2 Dname Dmgr_ssn 3NF Normalization Figure 14.11 Normalizing into 2NF and 3NF. (a) Normalizing EMP_PROJ into 2NF relations. (b) Normalizing EMP_DEPT into 3NF relations. === Page 514 === 14.4 General Definitions of Second and Third Normal Forms 483 14.3.6 Third Normal Form Third normal form (3NF) is based on the concept of transitive dependency. A func- tional dependency X → Y in a relation schema R is a transitive dependency if there exists a set of attributes Z in R that is neither a candidate key nor a subset of any key of R,11 and both X → Z and Z → Y hold. The dependency Ssn → Dmgr_ssn is transitive through Dnumber in EMP_DEPT in Figure 14.3(a), because both the dependencies Ssn → Dnumber and Dnumber → Dmgr_ssn hold and Dnumber is neither a key itself nor a subset of the key of EMP_DEPT. Intuitively, we can see that the dependency of Dmgr_ssn on Dnumber is undesirable in EMP_DEPT since Dnumber is not a key of EMP_DEPT. Definition. According to Codd’s original definition, a relation schema R is in 3NF if it satisfies 2NF and no nonprime attribute of R is transitively dependent on the primary key. The relation schema EMP_DEPT in Figure 14.3(a) is in 2NF, since no partial depen- dencies on a key exist. However, EMP_DEPT is not in 3NF because of the transitive dependency of Dmgr_ssn (and also Dname) on Ssn via Dnumber. We can normalize EMP_DEPT by decomposing it into the two 3NF relation schemas ED1 and ED2 shown in Figure 14.11(b). Intuitively, we see that ED1 and ED2 represent indepen- dent facts about employees and departments, both of which are entities in their own right. A NATURAL JOIN operation on ED1 and ED2 will recover the original relation EMP_DEPT without generating spurious tuples. Intuitively, we can see that any functional dependency in which the left-hand side is part (a proper subset) of the primary key, or any functional dependency in which the left-hand side is a nonkey attribute, is a problematic FD. 2NF and 3NF normalization remove these problem FDs by decomposing the original relation into new relations. In terms of the normalization process, it is not necessary to remove the partial dependen- cies before the transitive dependencies, but historically, 3NF has been defined with the assumption that a relation is tested for 2NF first before it is tested for 3NF. Moreover, the general definition of 3NF we present in Section 14.4.2 automatically covers the condition that the relation also satisfies 2NF. Table 14.1 informally summarizes the three normal forms based on primary keys, the tests used in each case, and the corre- sponding remedy or normalization performed to achieve the normal form. 14.4 General Definitions of Second and Third Normal Forms In general, we want to design our relation schemas so that they have neither partial nor transitive dependencies because these types of dependencies cause the update anomalies discussed in Section 14.1.2. The steps for normalization into 3NF rela- tions that we have discussed so far disallow partial and transitive dependencies on 11This is the general definition of transitive dependency. Because we are concerned only with primary keys in this section, we allow transitive dependencies where X is the primary key but Z may be (a subset of) a candidate key.

--- Chunk 7 ---
=== Page 508 === 14.3 Normal Forms Based on Primary Keys 477 The difference between a key and a superkey is that a key has to be minimal; that is, if we have a key K = {A1, A2, … , Ak} of R, then K − {Ai} is not a key of R for any Ai, 1 ≤ i ≤ k. In Figure 14.1, {Ssn} is a key for EMPLOYEE, whereas {Ssn}, {Ssn, Ename}, {Ssn, Ename, Bdate}, and any set of attributes that includes Ssn are all superkeys. If a relation schema has more than one key, each is called a candidate key. One of the candidate keys is arbitrarily designated to be the primary key, and the others are called secondary keys. In a practical relational database, each relation schema must have a primary key. If no candidate key is known for a relation, the entire rela- tion can be treated as a default superkey. In Figure 14.1, {Ssn} is the only candidate key for EMPLOYEE, so it is also the primary key. Definition. An attribute of relation schema R is called a prime attribute of R if it is a member of some candidate key of R. An attribute is called nonprime if it is not a prime attribute—that is, if it is not a member of any candidate key. In Figure 14.1, both Ssn and Pnumber are prime attributes of WORKS_ON, whereas other attributes of WORKS_ON are nonprime. We now present the first three normal forms: 1NF, 2NF, and 3NF. These were pro- posed by Codd (1972a) as a sequence to achieve the desirable state of 3NF relations by progressing through the intermediate states of 1NF and 2NF if needed. As we shall see, 2NF and 3NF independently attack different types of problems arising from problematic functional dependencies among attributes. However, for histori- cal reasons, it is customary to follow them in that sequence; hence, by definition a 3NF relation already satisfies 2NF. 14.3.4 First Normal Form First normal form (1NF)is now considered to be part of the formal definition of a relation in the basic (flat) relational model; historically, it was defined to disallow multivalued attributes, composite attributes, and their combinations. It states that the domain of an attribute must include only atomic (simple, indivisible) values and that the value of any attribute in a tuple must be a single value from the domain of that attribute. Hence, 1NF disallows having a set of values, a tuple of values, or a combination of both as an attribute value for a single tuple. In other words, 1NF disallows relations within relations or relations as attribute values within tuples. The only attribute values permitted by 1NF are single atomic (or indivisible) values. Consider the DEPARTMENT relation schema shown in Figure 14.1, whose primary key is Dnumber, and suppose that we extend it by including the Dlocations attribute as shown in Figure 14.9(a). We assume that each department can have a number of locations. The DEPARTMENT schema and a sample relation state are shown in Fig- ure 14.9. As we can see, this is not in 1NF because Dlocations is not an atomic attri- bute, as illustrated by the first tuple in Figure 14.9(b). There are two ways we can look at the Dlocations attribute: ■The domain of Dlocations contains atomic values, but some tuples can have a set of these values. In this case, Dlocations is not functionally dependent on the primary key Dnumber. === Page 509 === 478 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases ■The domain of Dlocations contains sets of values and hence is nonatomic. In this case, Dnumber → Dlocations because each set is considered a single mem- ber of the attribute domain.10 In either case, the DEPARTMENT relation in Figure 14.9 is not in 1NF; in fact, it does not even qualify as a relation according to our definition of relation in Section 3.1. There are three main techniques to achieve first normal form for such a relation: 1. Remove the attribute Dlocations that violates 1NF and place it in a separate relation DEPT_LOCATIONS along with the primary key Dnumber of DEPARTMENT. The primary key of this newly formed relation is the combi- nation {Dnumber, Dlocation}, as shown in Figure 14.2. A distinct tuple in DEPT_LOCATIONS exists for each location of a department. This decom- poses the non-1NF relation into two 1NF relations. Dname DEPARTMENT (a) DEPARTMENT (b) DEPARTMENT (c) Dnumber Dmgr_ssn Dlocations Dname Research Administration Headquarters 1 5 4 Dnumber 888665555 333445555 987654321 Dmgr_ssn {Houston} {Bellaire, Sugarland, Houston} {Stafford} Dlocations Dname Research Research Research Administration Headquarters Bellaire Sugarland Houston Stafford Houston 5 5 5 4 1 Dnumber 333445555 333445555 333445555 987654321 888665555 Dmgr_ssn Dlocation Figure 14.9 Normalization into 1NF. (a) A relation schema that is not in 1NF. (b) Sample state of relation DEPARTMENT. (c) 1NF version of the same relation with redundancy. 10In this case we can consider the domain of Dlocations to be the power set of the set of single locations; that is, the domain is made up of all possible subsets of the set of single locations. === Page 510 === 14.3 Normal Forms Based on Primary Keys 479 2. Expand the key so that there will be a separate tuple in the original DEPARTMENT relation for each location of a DEPARTMENT, as shown in Fig- ure 14.9(c). In this case, the primary key becomes the combination {Dnumber, Dlocation}. This solution has the disadvantage of introducing redundancy in the relation and hence is rarely adopted. 3. If a maximum number of values is known for the attribute—for example, if it is known that at most three locations can exist for a department—replace the Dlocations attribute by three atomic attributes: Dlocation1, Dlocation2, and Dlocation3. This solution has the disadvantage of introducing NULL values if most departments have fewer than three locations. It further introduces spurious semantics about the ordering among the location values; that ordering is not originally intended. Querying on this attribute becomes more difficult; for example, consider how you would write the query: List the departments that have ‘Bellaire’ as one of their locations in this design. For all these reasons, it is best to avoid this alternative. Of the three solutions above, the first is generally considered best because it does not suffer from redundancy and it is completely general; it places no max- imum limit on the number of values. In fact, if we choose the second solution, it will be decomposed further during subsequent normalization steps into the first solution. First normal form also disallows multivalued attributes that are themselves com- posite. These are called nested relations because each tuple can have a relation within it. Figure 14.10 shows how the EMP_PROJ relation could appear if nesting is allowed. Each tuple represents an employee entity, and a relation PROJS(Pnumber, Hours) within each tuple represents the employee’s projects and the hours per week that employee works on each project. The schema of this EMP_PROJ relation can be represented as follows: EMP_PROJ(Ssn, Ename, {PROJS(Pnumber, Hours)}) The set braces { } identify the attribute PROJS as multivalued, and we list the com- ponent attributes that form PROJS between parentheses ( ). Interestingly, recent trends for supporting complex objects (see Chapter 12) and XML data (see Chap- ter 13) attempt to allow and formalize nested relations within relational database systems, which were disallowed early on by 1NF. Notice that Ssn is the primary key of the EMP_PROJ relation in Figures 14.10(a) and (b), whereas Pnumber is the partial key of the nested relation; that is, within each tuple, the nested relation must have unique values of Pnumber. To normalize this into 1NF, we remove the nested relation attributes into a new relation and propa- gate the primary key into it; the primary key of the new relation will combine the partial key with the primary key of the original relation. Decomposition and pri- mary key propagation yield the schemas EMP_PROJ1 and EMP_PROJ2, as shown in Figure 14.10(c). This procedure can be applied recursively to a relation with multiple-level nesting to unnest the relation into a set of 1NF relations. This is useful in converting an === Page 511 === 480 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases unnormalized relation schema with many levels of nesting into 1NF relations. As an example, consider the following: CANDIDATE (Ssn, Name, {JOB_HIST (Company, Highest_position, {SAL_HIST (Year, Max_sal)})}) The foregoing describes data about candidates applying for jobs with their job his- tory as a nested relation within which the salary history is stored as a deeper nested EMP_PROJ (a) Projs Pnumber Hours Ssn Ename EMP_PROJ1 (c) Ssn Ename EMP_PROJ2 Hours Ssn Pnumber EMP_PROJ (b) Ssn 123456789 666884444 453453453 333445555 999887777 987987987 987654321 888665555 Zelaya, Alicia J. Jabbar, Ahmad V. Wallace, Jennifer S. Borg, James E. 32.5 7.5 40.0 20.0 20.0 10.0 10.0 10.0 10.0 30.0 10.0 35.0 5.0 20.0 15.0 NULL English, Joyce A. Narayan, Ramesh K. Smith, John B. Wong, Franklin T. Ename 3 1 2 1 2 2 20 3 10 30 10 10 20 30 30 20 Pnumber Hours Figure 14.10 Normalizing nested relations into 1NF. (a) Schema of the EMP_PROJ relation with a nested relation attribute PROJS. (b) Sample extension of the EMP_PROJ relation showing nested relations within each tuple. (c) Decomposition of EMP_PROJ into relations EMP_PROJ1 and EMP_PROJ2 by propagating the primary key. === Page 512 === 14.3 Normal Forms Based on Primary Keys 481 relation. The first normalization using internal partial keys Company and Year, respectively, results in the following 1NF relations: CANDIDATE_1 (Ssn, Name) CANDIDATE_JOB_HIST (Ssn, Company, Highest_position) CANDIDATE_SAL_HIST (Ssn, Company, Year, Max-sal) The existence of more than one multivalued attribute in one relation must be han- dled carefully. As an example, consider the following non-1NF relation: PERSON (Ss#, {Car_lic#}, {Phone#}) This relation represents the fact that a person has multiple cars and multiple phones. If strategy 2 above is followed, it results in an all-key relation: PERSON_IN_1NF (Ss#, Car_lic#, Phone#) To avoid introducing any extraneous relationship between Car_lic# and Phone#, all possible combinations of values are represented for every Ss#, giving rise to redun- dancy. This leads to the problems that are typically discovered at a later stage of normalization and that are handled by multivalued dependencies and 4NF, which we will discuss in Section 14.6. The right way to deal with the two multivalued attri- butes in PERSON shown previously is to decompose it into two separate relations, using strategy 1 discussed above: P1(Ss#, Car_lic#) and P2(Ss#, Phone#). A note about the relations that involve attributes that go beyond just numeric and character string data. It is becoming common in today’s databases to incorporate images, documents, video clips, audio clips, and so on. When these are stored in a relation, the entire object or file is treated as an atomic value, which is stored as a BLOB (binary large object) or CLOB (character large object) data type using SQL. For practical purposes, the object is treated as an atomic, single-valued attribute and hence it maintains the 1NF status of the relation. 14.3.5 Second Normal Form Second normal form (2NF) is based on the concept of full functional dependency. A functional dependency X → Y is a full functional dependency if removal of any attribute A from X means that the dependency does not hold anymore; that is, for any attribute A ε X, (X − {A}) does not functionally determine Y. A functional dependency X → Y is a partial dependency if some attribute A ε X can be removed from X and the dependency still holds; that is, for some A ε X, (X − {A}) → Y. In Figure 14.3(b), {Ssn, Pnumber} → Hours is a full dependency (neither Ssn → Hours nor Pnumber → Hours holds). However, the dependency {Ssn, Pnumber} → Ename is partial because Ssn → Ename holds. Definition. A relation schema R is in 2NF if every nonprime attribute A in R is fully functionally dependent on the primary key of R. The test for 2NF involves testing for functional dependencies whose left-hand side attributes are part of the primary key. If the primary key contains a single attribute, the test need not be applied at all. The EMP_PROJ relation in Figure 14.3(b) is in

--- Chunk 8 ---
=== Page 525 === 494 Chapter 14 Basics of Functional Dependencies and Normalization for Relational Databases and Ename is not a superkey of EMP. We decompose EMP into EMP_PROJECTS and EMP_DEPENDENTS, shown in Figure 14.15(b). Both EMP_PROJECTS and EMP_DEPENDENTS are in 4NF, because the MVDs Ename →→ Pname in EMP_PROJECTS and Ename →→ Dname in EMP_DEPENDENTS are trivial MVDs. No other nontrivial MVDs hold in either EMP_PROJECTS or EMP_DEPENDENTS. No FDs hold in these relation schemas either. 14.7 Join Dependencies and Fifth Normal Form In our discussion so far, we have pointed out the problematic functional dependen- cies and shown how they were eliminated by a process of repeated binary decompo- sition during the process of normalization to achieve 1NF, 2NF, 3NF, and BCNF. These binary decompositions must obey the NJB property for which we introduced a test in Section 14.5 while discussing the decomposition to achieve BCNF. Achiev- ing 4NF typically involves eliminating MVDs by repeated binary decompositions as well. However, in some cases there may be no nonadditive join decomposition of R into two relation schemas, but there may be a nonadditive join decomposition into more than two relation schemas. Moreover, there may be no functional dependency in R that violates any normal form up to BCNF, and there may be no nontrivial MVD present in R either that violates 4NF. We then resort to another dependency called the join dependency and, if it is present, carry out a multiway decomposition into fifth normal form (5NF). It is important to note that such a dependency is a peculiar semantic constraint that is difficult to detect in practice; therefore, normal- ization into 5NF is rarely done in practice. Definition. A join dependency (JD), denoted by JD(R1, R2, … , Rn), specified on relation schema R, specifies a constraint on the states r of R. The constraint states that every legal state r of R should have a nonadditive join decomposition into R1, R2, … , Rn. Hence, for every such r we have * (πR1(r), πR2(r), … , πRn(r)) = r Notice that an MVD is a special case of a JD where n = 2. That is, a JD denoted as JD(R1, R2) implies an MVD (R1 ∩ R2) →→ (R1 − R2)(or, by symmetry, (R1 ∩ R2) →→ (R2 − R1)). A join dependency JD(R1, R2, … , Rn), specified on relation schema R, is a trivial JD if one of the relation schemas Ri in JD(R1, R2, … , Rn) is equal to R. Such a dependency is called trivial because it has the nonadditive join property for any relation state r of R and thus does not specify any constraint on R. We can now define the fifth normal form, which is also called project-join normal form. Definition. A relation schema R is in fifth normal form (5NF) (or project-join normal form (PJNF)) with respect to a set F of functional, multivalued, and join dependencies if, for every nontrivial join dependency JD(R1, R2, … , Rn) in F+ (that is, implied by F),22 every Ri is a superkey of R. 22Again, F+ refers to the cover of functional dependencies F, or all dependencies that are implied by F. This is defined in Section 15.1. === Page 526 === 14.6 Summary 495 For an example of a JD, consider once again the SUPPLY all-key relation in Fig- ure 14.15(c). Suppose that the following additional constraint always holds: Whenever a supplier s supplies part p, and a project j uses part p, and the supplier s supplies at least one part to project j, then supplier s will also be supplying part p to project j. This constraint can be restated in other ways and specifies a join dependency JD(R1, R2, R3) among the three projections R1 (Sname, Part_name), R2 (Sname, Proj_name), and R3 (Part_name, Proj_name) of SUPPLY. If this constraint holds, the tuples below the dashed line in Figure 14.15(c) must exist in any legal state of the SUPPLY relation that also contains the tuples above the dashed line. Figure 14.15(d) shows how the SUPPLY relation with the join dependency is decomposed into three relations R1, R2, and R3 that are each in 5NF. Notice that applying a natural join to any two of these relations produces spurious tuples, but applying a natural join to all three together does not. The reader should verify this on the sample relation in Figure 14.15(c) and its projections in Figure 14.15(d). This is because only the JD exists, but no MVDs are specified. Notice, too, that the JD(R1, R2, R3) is specified on all legal relation states, not just on the one shown in Figure 14.15(c). Discovering JDs in practical databases with hundreds of attributes is next to impos- sible. It can be done only with a great degree of intuition about the data on the part of the designer. Therefore, the current practice of database design pays scant atten- tion to them. One result due to Date and Fagin (1992) relates to conditions detected using f.d.’s alone and ignores JDs completely. It states: “If a relation schema is in 3NF and each of its keys consists of a single attribute, it is also in 5NF.” 14.8 Summary In this chapter we discussed several pitfalls in relational database design using intu- itive arguments. We identified informally some of the measures for indicating whether a relation schema is good or bad, and we provided informal guidelines for a good design. These guidelines are based on doing a careful conceptual design in the ER and EER model, following the mapping procedure in Chapter 9 to map enti- ties and relationships into relations. Proper enforcement of these guidelines and lack of redundancy will avoid the insertion/deletion/update anomalies and genera- tion of spurious data. We recommended limiting NULL values, which cause prob- lems during SELECT, JOIN, and aggregation operations. Then we presented some formal concepts that allow us to do relational design in a top-down fashion by ana- lyzing relations individually. We defined this process of design by analysis and decomposition by introducing the process of normalization. We defined the concept of functional dependency, which is the basic tool for ana- lyzing relational schemas, and we discussed some of its properties. Functional dependencies specify semantic constraints among the attributes of a relation schema. Next we described the normalization process for achieving good designs by testing relations for undesirable types of problematic functional dependencies. We provided a treatment of successive normalization based on a predefined pri- mary key in each relation, and we then relaxed this requirement and provided more
